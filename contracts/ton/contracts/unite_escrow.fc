#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/jetton-utils.fc";

;; Storage structure for Unite Escrow
;; uint32 state (0=active, 1=withdrawn, 2=cancelled)
;; uint256 order_hash
;; uint256 hashlock
;; slice maker_address
;; slice taker_address  
;; slice token_address (jetton master or null for TON)
;; uint64 total_amount
;; uint64 safety_deposit_per_unit
;; uint32 deployed_at
;; uint32 src_withdrawal_time
;; uint32 src_public_withdrawal_time
;; uint32 src_cancellation_time
;; uint32 src_public_cancellation_time
;; uint32 dst_withdrawal_time
;; uint32 dst_public_withdrawal_time
;; uint32 dst_cancellation_time
;; int is_source (1 for source, 0 for destination)
;; uint32 src_cancellation_timestamp (only for destination)
;; dict resolvers (resolver_address -> [partial_amount, safety_deposit, jetton_wallet])
;; uint64 total_partial_amount
;; int funds_distributed

;; Load storage data
(int, int, int, slice, slice, slice, int, int, int, int, int, int, int, int, int, int, int, int, cell, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    
    int state = ds~load_uint(32);
    int order_hash = ds~load_uint(256);
    int hashlock = ds~load_uint(256);
    slice maker = ds~load_msg_addr();
    slice taker = ds~load_msg_addr();
    slice token = ds~load_msg_addr();
    int total_amount = ds~load_uint(64);
    int safety_deposit = ds~load_uint(64);
    int deployed_at = ds~load_uint(32);
    int src_withdrawal = ds~load_uint(32);
    int src_public_withdrawal = ds~load_uint(32);
    int src_cancellation = ds~load_uint(32);
    int src_public_cancellation = ds~load_uint(32);
    int dst_withdrawal = ds~load_uint(32);
    int dst_public_withdrawal = ds~load_uint(32);
    int dst_cancellation = ds~load_uint(32);
    int is_source = ds~load_int(1);
    int src_cancellation_ts = ds~load_uint(32);
    cell resolvers = ds~load_dict();
    int total_partial = ds~load_uint(64);
    int funds_distributed = ds~load_int(1);
    
    return (state, order_hash, hashlock, maker, taker, token, total_amount, safety_deposit,
            deployed_at, src_withdrawal, src_public_withdrawal, src_cancellation, src_public_cancellation,
            dst_withdrawal, dst_public_withdrawal, dst_cancellation, is_source, src_cancellation_ts,
            resolvers, total_partial, funds_distributed);
}

;; Save storage data
() save_data(int state, int order_hash, int hashlock, slice maker, slice taker, slice token,
            int total_amount, int safety_deposit, int deployed_at, int src_withdrawal,
            int src_public_withdrawal, int src_cancellation, int src_public_cancellation,
            int dst_withdrawal, int dst_public_withdrawal, int dst_cancellation,
            int is_source, int src_cancellation_ts, cell resolvers, int total_partial, int funds_distributed) impure inline {
    set_data(begin_cell()
        .store_uint(state, 32)
        .store_uint(order_hash, 256)
        .store_uint(hashlock, 256)
        .store_slice(maker)
        .store_slice(taker)
        .store_slice(token)
        .store_uint(total_amount, 64)
        .store_uint(safety_deposit, 64)
        .store_uint(deployed_at, 32)
        .store_uint(src_withdrawal, 32)
        .store_uint(src_public_withdrawal, 32)
        .store_uint(src_cancellation, 32)
        .store_uint(src_public_cancellation, 32)
        .store_uint(dst_withdrawal, 32)
        .store_uint(dst_public_withdrawal, 32)
        .store_uint(dst_cancellation, 32)
        .store_int(is_source, 1)
        .store_uint(src_cancellation_ts, 32)
        .store_dict(resolvers)
        .store_uint(total_partial, 64)
        .store_int(funds_distributed, 1)
        .end_cell());
}

;; Handle initialization for source escrow
() handle_initialize(slice in_msg_body, int msg_value, slice sender_address) impure {
    int order_hash = in_msg_body~load_uint(256);
    int hashlock = in_msg_body~load_uint(256);
    slice maker = in_msg_body~load_msg_addr();
    slice taker = in_msg_body~load_msg_addr();
    slice token = in_msg_body~load_msg_addr();
    int total_amount = in_msg_body~load_uint(64);
    int safety_deposit = in_msg_body~load_uint(64);
    int src_withdrawal = in_msg_body~load_uint(32);
    int src_public_withdrawal = in_msg_body~load_uint(32);
    int src_cancellation = in_msg_body~load_uint(32);
    int src_public_cancellation = in_msg_body~load_uint(32);
    int dst_withdrawal = in_msg_body~load_uint(32);
    int dst_public_withdrawal = in_msg_body~load_uint(32);
    int dst_cancellation = in_msg_body~load_uint(32);
    int is_source = in_msg_body~load_int(1);
    int resolver_partial_amount = in_msg_body~load_uint(64);
    
    ;; Calculate proportional safety deposit for this resolver
    int required_deposit = (safety_deposit * resolver_partial_amount) / total_amount;
    throw_unless(ERROR_INSUFFICIENT_FUNDS, msg_value >= required_deposit);
    
    ;; Initialize empty resolver dict
    cell resolvers = new_dict();
    
    ;; Add first resolver
    slice resolver_data = begin_cell()
        .store_uint(resolver_partial_amount, 64)
        .store_uint(msg_value, 64)
        .store_slice(sender_address)
        .end_cell().begin_parse();
    
    resolvers~udict_set(267, sender_address.slice_hash(), resolver_data);
    
    save_data(STATE_ACTIVE, order_hash, hashlock, maker, taker, token, total_amount, safety_deposit,
             now(), src_withdrawal, src_public_withdrawal, src_cancellation, src_public_cancellation,
             dst_withdrawal, dst_public_withdrawal, dst_cancellation, is_source, 0,
             resolvers, resolver_partial_amount, 0);
}

;; Handle withdrawal with secret (permissionless)
() handle_withdraw_with_secret(slice in_msg_body, slice sender_address) impure {
    var (state, order_hash, hashlock, maker, taker, token, total_amount, safety_deposit,
         deployed_at, src_withdrawal, src_public_withdrawal, src_cancellation, src_public_cancellation,
         dst_withdrawal, dst_public_withdrawal, dst_cancellation, is_source, src_cancellation_ts,
         resolvers, total_partial, funds_distributed) = load_data();
    
    throw_unless(ERROR_INVALID_STATE, state == STATE_ACTIVE);
    throw_if(ERROR_ALREADY_WITHDRAWN, funds_distributed);
    
    int secret = in_msg_body~load_uint(256);
    
    ;; Verify secret
    int computed_hash = string_hash(begin_cell().store_uint(secret, 256).end_cell().begin_parse());
    throw_unless(ERROR_INVALID_SECRET, computed_hash == hashlock);
    
    ;; Calculate caller reward if after time limit
    int current_time = now();
    int caller_reward = 0;
    
    if (is_source) {
        if (current_time >= (deployed_at + src_public_withdrawal)) {
            if (~ equal_slices(sender_address, maker)) {
                (slice resolver_data, int is_resolver) = resolvers.udict_get?(267, sender_address.slice_hash());
                if (~ is_resolver) {
                    caller_reward = total_partial * 10 / 100;
                }
            }
        }
    } else {
        if (current_time >= (deployed_at + dst_public_withdrawal)) {
            if (~ equal_slices(sender_address, maker)) {
                (slice resolver_data, int is_resolver) = resolvers.udict_get?(267, sender_address.slice_hash());
                if (~ is_resolver) {
                    caller_reward = total_partial * 10 / 100;
                }
            }
        }
    }
    
    ;; Distribute funds
    if (is_source) {
        distribute_source_funds(resolvers, token, caller_reward, sender_address);
    } else {
        distribute_destination_funds(resolvers, token, maker, total_partial, caller_reward, sender_address);
    }
    
    ;; Update state
    save_data(STATE_WITHDRAWN, order_hash, hashlock, maker, taker, token, total_amount, safety_deposit,
             deployed_at, src_withdrawal, src_public_withdrawal, src_cancellation, src_public_cancellation,
             dst_withdrawal, dst_public_withdrawal, dst_cancellation, is_source, src_cancellation_ts,
             resolvers, total_partial, -1);
}

;; Distribute funds for source chain
() distribute_source_funds(cell resolvers, slice token, int caller_reward, slice caller) impure {
    int resolver_key = -1;
    do {
        (resolver_key, slice resolver_data, int f) = resolvers.udict_get_next?(267, resolver_key);
        if (f) {
            int partial_amount = resolver_data~load_uint(64);
            int safety_deposit = resolver_data~load_uint(64);
            slice resolver_addr = resolver_data~load_msg_addr();
            
            int actual_deposit = safety_deposit;
            if (caller_reward > 0) {
                int deduction = safety_deposit * 10 / 100;
                actual_deposit = safety_deposit - deduction;
            }
            
            if (token.slice_empty?()) {
                send_ton(resolver_addr, partial_amount + actual_deposit);
            } else {
                send_jettons(token, resolver_addr, partial_amount, my_address());
                send_ton(resolver_addr, actual_deposit);
            }
        }
    } until (~ f);
    
    if (caller_reward > 0) {
        send_ton(caller, caller_reward);
    }
}

;; Distribute funds for destination chain
() distribute_destination_funds(cell resolvers, slice token, slice maker, int total_amount, int caller_reward, slice caller) impure {
    if (token.slice_empty?()) {
        send_ton(maker, total_amount);
    } else {
        send_jettons(token, maker, total_amount, my_address());
    }
    
    int resolver_key = -1;
    do {
        (resolver_key, slice resolver_data, int f) = resolvers.udict_get_next?(267, resolver_key);
        if (f) {
            resolver_data~load_uint(64);
            int safety_deposit = resolver_data~load_uint(64);
            slice resolver_addr = resolver_data~load_msg_addr();
            
            int actual_deposit = safety_deposit;
            if (caller_reward > 0) {
                int deduction = safety_deposit * 10 / 100;
                actual_deposit = safety_deposit - deduction;
            }
            
            send_ton(resolver_addr, actual_deposit);
        }
    } until (~ f);
    
    if (caller_reward > 0) {
        send_ton(caller, caller_reward);
    }
}

;; Send TON
() send_ton(slice dest_addr, int amount) impure {
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(dest_addr)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 1);
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == OP_INITIALIZE) {
        handle_initialize(in_msg_body, msg_value, sender_address);
        return ();
    }
    
    if (op == OP_WITHDRAW_WITH_SECRET) {
        handle_withdraw_with_secret(in_msg_body, sender_address);
        return ();
    }
    
    throw(0xffff);
}

;; Get methods
int get_state() method_id {
    var (state, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = load_data();
    return state;
}

int get_order_hash() method_id {
    var (_, order_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = load_data();
    return order_hash;
}

int get_total_partial_amount() method_id {
    var (_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, total_partial, _) = load_data();
    return total_partial;
}
