#include "imports/stdlib.fc";
#include "imports/constants.fc";

;; Storage structure for Factory:
;; slice owner_address
;; cell escrow_code
;; dict src_escrows (order_hash -> escrow_address)
;; dict dst_escrows (order_hash -> escrow_address) 
;; dict resolver_partial_amounts
;; dict resolver_safety_deposits
;; dict total_filled_amounts

const int OP_CREATE_SRC_ESCROW = 1;
const int OP_CREATE_DST_ESCROW = 2;
const int OP_SET_ESCROW_CODE = 3;

;; Load storage
(slice, cell, cell, cell, cell, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    slice owner = ds~load_msg_addr();
    cell escrow_code = ds~load_ref();
    cell src_escrows = ds~load_dict();
    cell dst_escrows = ds~load_dict();
    cell resolver_amounts = ds~load_dict();
    cell resolver_deposits = ds~load_dict();
    cell total_amounts = ds~load_dict();
    return (owner, escrow_code, src_escrows, dst_escrows, resolver_amounts, resolver_deposits, total_amounts);
}

;; Save storage
() save_data(slice owner, cell escrow_code, cell src_escrows, cell dst_escrows, 
            cell resolver_amounts, cell resolver_deposits, cell total_amounts) impure inline {
    set_data(begin_cell()
        .store_slice(owner)
        .store_ref(escrow_code)
        .store_dict(src_escrows)
        .store_dict(dst_escrows)
        .store_dict(resolver_amounts)
        .store_dict(resolver_deposits)
        .store_dict(total_amounts)
        .end_cell());
}

;; Calculate escrow address
slice calculate_escrow_address(int order_hash, cell escrow_code, int is_source, int workchain) inline {
    cell init_data = begin_cell()
        .store_uint(0, 32)
        .store_uint(order_hash, 256)
        .store_uint(is_source, 1)
        .end_cell();
    
    cell state_init = begin_cell()
        .store_maybe_ref(escrow_code)
        .store_maybe_ref(init_data)
        .end_cell();
    
    int hash = cell_hash(state_init);
    slice addr = begin_cell()
        .store_uint(4, 3)
        .store_int(workchain, 8)
        .store_uint(hash, 256)
        .end_cell().begin_parse();
    
    return addr;
}

;; Deploy escrow contract
slice deploy_escrow(slice escrow_addr, cell escrow_code, cell init_data, int value, cell init_msg) impure {
    cell state_init = begin_cell()
        .store_maybe_ref(escrow_code)
        .store_maybe_ref(init_data)
        .end_cell();
    
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(escrow_addr)
        .store_coins(value)
        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
        .store_ref(state_init)
        .store_ref(init_msg)
        .end_cell();
    
    send_raw_message(msg, 1);
    return escrow_addr;
}

;; Handle source escrow creation
() handle_create_src_escrow(slice in_msg_body, int msg_value, slice sender_address) impure {
    var (owner, escrow_code, src_escrows, dst_escrows, resolver_amounts, resolver_deposits, total_amounts) = load_data();
    
    int order_hash = in_msg_body~load_uint(256);
    int hashlock = in_msg_body~load_uint(256);
    slice maker = in_msg_body~load_msg_addr();
    slice taker = in_msg_body~load_msg_addr();
    slice token = in_msg_body~load_msg_addr();
    int total_amount = in_msg_body~load_uint(64);
    int safety_deposit_per_unit = in_msg_body~load_uint(64);
    int src_withdrawal = in_msg_body~load_uint(32);
    int src_public_withdrawal = in_msg_body~load_uint(32);
    int src_cancellation = in_msg_body~load_uint(32);
    int src_public_cancellation = in_msg_body~load_uint(32);
    int dst_withdrawal = in_msg_body~load_uint(32);
    int dst_public_withdrawal = in_msg_body~load_uint(32);
    int dst_cancellation = in_msg_body~load_uint(32);
    int partial_amount = in_msg_body~load_uint(64);
    
    throw_unless(ERROR_INVALID_AMOUNT, (partial_amount > 0) & (partial_amount <= total_amount));
    
    int required_deposit = (safety_deposit_per_unit * partial_amount) / total_amount;
    throw_unless(ERROR_INSUFFICIENT_DEPOSIT, msg_value >= required_deposit);
    
    slice escrow_addr = calculate_escrow_address(order_hash, escrow_code, 1, 0);
    
    (slice existing_escrow, int escrow_exists) = src_escrows.udict_get?(256, order_hash);
    
    if (~ escrow_exists) {
        cell init_data = begin_cell()
            .store_uint(0, 32)
            .store_uint(order_hash, 256)
            .store_uint(1, 1)
            .end_cell();
        
        cell init_msg = begin_cell()
            .store_uint(0, 32)
            .store_uint(OP_INITIALIZE, 32)
            .store_uint(0, 64)
            .store_uint(order_hash, 256)
            .store_uint(hashlock, 256)
            .store_slice(maker)
            .store_slice(taker)
            .store_slice(token)
            .store_uint(total_amount, 64)
            .store_uint(safety_deposit_per_unit, 64)
            .store_uint(src_withdrawal, 32)
            .store_uint(src_public_withdrawal, 32)
            .store_uint(src_cancellation, 32)
            .store_uint(src_public_cancellation, 32)
            .store_uint(dst_withdrawal, 32)
            .store_uint(dst_public_withdrawal, 32)
            .store_uint(dst_cancellation, 32)
            .store_int(-1, 1)
            .store_uint(partial_amount, 64)
            .end_cell();
        
        deploy_escrow(escrow_addr, escrow_code, init_data, msg_value, init_msg);
        src_escrows~udict_set(256, order_hash, begin_cell().store_slice(escrow_addr).end_cell().begin_parse());
    }
    
    ;; Track participation
    (slice total_slice, int total_found) = total_amounts.udict_get?(256, order_hash);
    int current_total = 0;
    if (total_found) {
        current_total = total_slice~load_uint(64);
    }
    current_total += partial_amount;
    total_amounts~udict_set(256, order_hash, begin_cell().store_uint(current_total, 64).end_cell().begin_parse());
    
    save_data(owner, escrow_code, src_escrows, dst_escrows, resolver_amounts, resolver_deposits, total_amounts);
}

;; Main message receiver
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == OP_CREATE_SRC_ESCROW) {
        handle_create_src_escrow(in_msg_body, msg_value, sender_address);
        return ();
    }
    
    throw(0xffff);
}

;; Get methods
slice get_src_escrow_address(int order_hash) method_id {
    var (_, escrow_code, src_escrows, _, _, _, _) = load_data();
    
    (slice escrow_addr, int found) = src_escrows.udict_get?(256, order_hash);
    if (found) {
        return escrow_addr~load_msg_addr();
    }
    
    return calculate_escrow_address(order_hash, escrow_code, 1, 0);
}

int get_total_filled_amount(int order_hash) method_id {
    var (_, _, _, _, _, _, total_amounts) = load_data();
    
    (slice total_slice, int found) = total_amounts.udict_get?(256, order_hash);
    if (found) {
        return total_slice~load_uint(64);
    }
    
    return 0;
}
